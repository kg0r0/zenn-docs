---
title: "OAuth 2.1ã®å·®åˆ†ã‚’è¦‹å®ˆã‚‹ä¼š : draft 04-05"
emoji: "ğŸ™†"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["OAuth", "ietf", "rfc"]
published: false
---

æœ¬æŠ•ç¨¿ã¯OAuth 2.1ã£ã¦å‘¼ã°ã‚ŒãŸã„æ„Ÿã‚’å‡ºã—ã¦ã‚‹ä»•æ§˜ã®å·®åˆ†ã‚’è¦‹å®ˆã‚‹ä¼šã§ã™ã€‚

æœ¬æŠ•ç¨¿å«ã‚ã€å·®åˆ†ã‚’ ã‚¹ã‚¯ãƒ©ãƒƒãƒ— - [OAuth 2.1ã‚’è¦‹å®ˆã‚‹ä¼š](https://zenn.dev/ritou/scraps/098107802f952b) ã§ã¾ã¨ã‚ã¦ã„ã¾ã™ã€‚

## å·®åˆ†

[å·®åˆ†](https://tools.ietf.org/wg/oauth/draft-ietf-oauth-v2-1/draft-ietf-oauth-v2-1-05-from-04.wdiff.html)

[draft 05](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-05.txt) ã«ãŠã‘ã‚‹ä¸»ãªå·®åˆ†ã¨ã—ã¦ã¯ã€[Appendix E.  Document History](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-05.txt#appendix-E)ã«è¨˜è¼‰ã®ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
å¤‰æ›´å·®åˆ†ã®å…¨ä½“ã‚’è¦‹ã‚‹ã¨å¤šãã®å·®åˆ†ãŒã‚ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€ç« ã®ç§»å‹•ãªã©ã«ä¼´ã†ã‚‚ã®ãŒå¤šãã†ã§ã™ã€‚å¤§ããªå¤‰æ›´ã§è¨€ã†ã¨ã€implicit flow ã®å‰Šé™¤ã«é–¢ã™ã‚‹ç« ã®è¿½åŠ ã§ã—ã‚‡ã†ã‹ã€‚ãã®ä»–ã«ã‚‚ç‰¹ã« TLS ã«é–¢ã™ã‚‹æ¯”è¼ƒçš„ç´°ã‹ã„è¦ä»¶ãŒè‰²ã€…ã¨æ›´æ–°ã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

>   *  Added a section about the removal of the implicit flow
>
>  *  Moved many normative requirements from security considerations
>     into the appropriate inline sections
>
>   *  Reorganized and consolidated TLS language
>
>   *  Require TLS on redirect URIs except for localhost/custom URL
>     scheme
>
> *  Updated refresh token guidance to match security BCP
>

æœ¬æŠ•ç¨¿ã§ã¯ã€ä¸Šè¨˜ã®å†…å®¹ã‚’æŠ‘ãˆã¤ã¤ã€ãã®ä»–ã®ç´°ã‹ã„å¤‰æ›´ç‚¹ã«ã¤ã„ã¦ã‚‚ã€ã–ã£ãã‚Šã¨ç¢ºèªã—ã¦ã„ãã¾ã™ã€‚

### ç›®æ¬¡

ç›®æ¬¡ã«ãŠã‘ã‚‹å¤§ããªå·®åˆ†ã¨ã—ã¦ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã—ãŸã€‚ãã®ä»–ã®å·®åˆ†ã«ã¤ã„ã¦ã¯ã€ç« ã®å ´æ‰€ãŒç§»å‹•ã—ãŸã ã‘ã®ã‚‚ã®ã§ã‚ã‚Šã€ç‰¹ã«å‰Šé™¤ã•ã‚ŒãŸã‚Šã€æ–°è¦ã«è¿½åŠ ã•ã‚ŒãŸã‚‚ã®ã¯ç„¡ã•ãã†ã§ã—ãŸã€‚

- TLS Version -> Communication security (å¤‰æ›´)
- Endpoint Request Confidentiality (å‰Šé™¤)
- Preventing CSRF Attacks (è¿½åŠ )
- Preventing Mix-Up Attacks (è¿½åŠ )
- Refresh Tokens (å‰Šé™¤)
- Request Confidentiality (å‰Šé™¤)
- Removal of the OAuth 2.0 Implicit grant (è¿½åŠ )
- Security Considerations in Native Apps (è¿½åŠ )

### 1.5. Communication security

ç« ã®ã‚¿ã‚¤ãƒˆãƒ«ãŒã€ŒTLS Versionã€ã‹ã‚‰ã€ŒCommunication securityã€ã«å¤‰ã‚ã£ã¦ã„ã¾ã™ã€‚
å†…å®¹ã«é–¢ã—ã¦ã¯ã€ä»¥å‰ã®ã€ŒTLS Versionã€ã§ã¯ã€ã–ã£ãã‚Šé©åˆ‡ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã® TLS ã‚’ã„ã¤ã§ã‚‚åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒè¦ä»¶ã¨ã—ã¦è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã—ãŸãŒã€ã€ŒCommunication securityã€ã§ã¯ã€TLS ã«é™å®šã—ãªã„ã‚ˆã†ãªè¨˜è¼‰ã«è¡¨ç¾ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã¾ã™ã€‚

>    Implementations MUST use a mechanism to provide communication authentication, integrity and confidentiality such as Transport-Layer Security [RFC8446], to protect the exchange of clear-text credentials and tokens either in the payload body or in header fields from eavesdropping, tampering, and message forgery (eg. see Section 2.4.1, Section 7.6, Section 3.2, and Section 5.2).

ãªãŠã€ãƒ«ãƒ¼ãƒ—ãƒãƒƒã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã¯ä¾‹å¤–ã¨ã—ã¦ http ã‚¹ã‚­ãƒ¼ãƒ ã‚’åˆ©ç”¨ã—ã¦ã‚‚è‰¯ã„ã¨ã®è¨˜è¼‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚

>    OAuth URLs MUST use the https scheme except for loopback interface redirect URIs, which MAY use the http scheme. 

ã¾ãŸã€TLS ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŠã‚ˆã³åˆ©ç”¨ã•ã‚Œã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã“ã®ä»•æ§˜ã®ç¯„å›²å¤–ã§ã‚ã‚‹ã“ã¨ãŒæ˜è¨˜ã•ã‚Œã¾ã—ãŸã€‚

>    The identification of the TLS versions and algorithms is outside the scope of this specification. 

### 2.3.2. Registration Requirements

èªå¯ã‚µãƒ¼ãƒãƒ¼ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å¯¾ã—ã¦è¤‡æ•°ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã®ç™»éŒ²ã‚’è¨±å¯ã—ã¦ã‚‚ã‚ˆã„ã“ã¨ã®è¨˜è¼‰ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚

>    The authorization server MAY allow the client to register multiple redirect URIs.

ã¾ãŸã€URI ã‚¹ã‚­ãƒ¼ãƒ ã®é‡è¤‡ã‚’è€ƒæ…®ã—ãŸè¦ä»¶ãŒè¿½è¨˜ã•ã‚Œã¦ã„ã¾ã™ã€‚

>    In addition to the collision-resistant properties, this can help to prove ownership in the event of a dispute where two apps claim the same private-use URI scheme (where one app is acting maliciously). For example, if two apps claimed com.example.app, the owner of example.com could petition the app store operator to remove the counterfeit app.  Such a petition is harder to prove if a generic URI scheme was used.

ã‚ªãƒ¼ãƒ—ãƒ³ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚’é˜²ããŸã‚ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã®è¦ä»¶ãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå‘ã‘ã«è¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚

>   Clients MUST NOT expose URLs that forward the user's browser to arbitrary URIs obtained from a query parameter ("open redirector"). Open redirectors can enable exfiltration of authorization codes and access tokens, see (#open_redirector_on_client).

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URL ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«å¤‰ãˆã‚‹ã®ã§ã¯ãªãã€åˆ¥ã®çŠ¶æ…‹ã‚’æŒã¤ã‚ˆã†ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’åˆ©ç”¨ã—ã¦ã‚‚è‰¯ã„ (MAY) ã¨ã®ã“ã¨ã§ã™ã€‚

>    The client MAY use the state request parameter to achieve per-request customization if needed rather than varying the redirect URI per request. 


### 2.3.3. Preventing CSRF Attacks

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ CSRF æ”»æ’ƒã®å¯¾ç­–ã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ (MUST) è¦ä»¶ãŒè¿½è¨˜ã•ã‚Œã¦ã„ã¾ã™ã€‚

>  Clients MUST prevent Cross-Site Request Forgery (CSRF) attacks.  In this context, CSRF refers to requests to the redirection endpoint that do not originate at the authorization server, but a malicious third party (see Section 4.4.1.8. of [RFC6819] for details). 

å…·ä½“çš„ã«ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€èªå¯ã‚µãƒ¼ãƒãƒ¼ãŒ code_challenge ã®ãƒªãƒ¬ãƒ¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã‚ˆã†ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

> Clients that have ensured that the authorization server supports the code_challenge parameter MAY rely the CSRF protection provided by that mechanism. 

ã¾ãŸã€OpenID Connect ã«ãŠã„ã¦ã¯ã€CSRF å¯¾ç­–ã¨ã—ã¦ nonce ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®æ¤œè¨¼ã‚’ã™ã‚‹ã‚ˆã†ã«è¨˜è¼‰ãŒã‚ã‚Šã¾ã™ã€‚

> In OpenID Connect flows, validating the nonce parameter provides CSRF protection. 

ãã®ã»ã‹ã®æ–¹æ³•ã¨ã—ã¦ã€ãƒ¯ãƒ³ã‚¿ã‚¤ãƒ ã® CSRF ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ state ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦åˆ©ç”¨ã™ã‚‹ã“ã¨ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

> Otherwise, one-time use CSRF tokens carried in the state parameter that are securely bound to the user agent MUST be used for CSRF protection (see (#csrf_countermeasures)).

### 2.3.4. Preventing Mix-Up Attacks

ä»¥å‰ã¯ Protecting the Authorization Code Flow ã«å«ã¾ã‚Œã¦ã„ãŸ Mix-Up Attack ã®å¯¾ç­–ã«é–¢ã™ã‚‹è¦ä»¶ãŒä¸€ã¤ã®ç« ã¨ã—ã¦è¨˜è¼‰ã•ã‚Œã¾ã—ãŸã€‚

### 2.3.5. Invalid Endpoint 

èªå¯ã‚µãƒ¼ãƒãƒ¼ãŒèªå¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã®æ¤œè¨¼ã«å¤±æ•—ã—ãŸéš›ã®å‡¦ç†ãŒè¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚å•é¡ŒãŒç™ºç”Ÿã—ãŸéš›ã¯ãƒªã‚½ãƒ¼ã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ã«ãã®ã‚¨ãƒ©ãƒ¼ã‚’ä¼ãˆã‚‹ã¹ãã§ã‚ã‚‹ã“ã¨ã€ã¾ãŸã€ãã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã«å¯¾ã—ã¦è‡ªå‹•ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¦ã¯ãªã‚‰ãªã„ã“ã¨ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

>   If an authorization request fails validation due to a missing, invalid, or mismatching redirect URI, the authorization server SHOULD inform the resource owner of the error and MUST NOT automatically redirect the user agent to the invalid redirect URI.

### 2.4.  Client Authentication

>   The authorization server MUST only rely on client authentication if the process of issuance/registration and distribution of the underlying credentials ensures their confidentiality.

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆèªè¨¼ãŒä¸å¯èƒ½ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ (= Public Client) ã‚’æƒ³å®šã—ãŸè¦ä»¶ãŒè¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚

>   When client authentication is not possible, the authorization server SHOULD employ other means to validate the client's identity - for example, by requiring the registration of the client redirect URI or enlisting the resource owner to confirm identity.  A valid redirect URI is not sufficient to verify the client's identity when asking for resource owner authorization but can be used to prevent delivering credentials to a counterfeit client after obtaining resource owner authorization.

>   The authorization server MAY establish a client authentication method with public clients, which converts them to credentialed clients.However, the authorization server MUST NOT rely on credentialed client authentication for the purpose of identifying the client.

>   The authorization server MUST consider the security implications of interacting with unauthenticated clients and take measures to limit the potential exposure of tokens issued to such clients, (e.g., limiting the lifetime of refresh tokens).

>   The privileges an authorization server associates with a certain client identity MUST depend on the assessment of the overall process for client identification and client credential lifecycle management. See Section 7.2 for additional details.


### 3.1.  Authorization Endpoint

>    An authorization server that redirects a request potentially containing user credentials MUST avoid forwarding these user credentials accidentally (see Section 7.5.2 for details).

### 4.1.1.  Authorization Request

è¦ä»¶ãŒä¸€éƒ¨è¿½è¨˜ã•ã‚Œã¦ã„ã¾ã™ã€‚
ä»¥ä¸‹ã®é€šã‚Šã€èªå¯ã‚µãƒ¼ãƒãƒ¼ã¯ã€code_challenge ã¨ code_verifier ã®ã‚µãƒãƒ¼ãƒˆã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ (MUST) ã¨ã®è¦ä»¶ãŒè¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚

>   Authorization servers MUST support the code_challenge and code_verifier parameters.

ä»¥ä¸‹ã®é€šã‚Šã€state ã¨ scope ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«ã¯ã€æ©Ÿå¯†æ€§ã®é«˜ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„ãƒªã‚½ãƒ¼ã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ã®æƒ…å ±ã‚’å¹³æ–‡ã§å«ã¾ã‚Œã‚‹ã¹ãã§ã¯ãªã„ã¨ã®è¦ä»¶ãŒè¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚

>   The state and scope parameters SHOULD NOT include sensitive client or resource owner information in plain text, as they can be transmitted over insecure channels or stored insecurely.


### 4.1.2.  Authorization Response

>    Clients MUST prevent injection (replay) of authorization codes into the authorization response by attackers.  Using code_challenge and code_verifier prevents injection of authorization codes since the authorization server will reject a token request with a mismatched code_verifier.  See Section 7.6 for more details.

### 4.1.3.  Token Endpoint Extension

redirect_uri ã®æ¤œè¨¼ã«ã¤ã„ã¦ã€èªå¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã« redirect_uri ãŒå«ã¾ã‚Œã¦ã„ãªã‹ã£ãŸå ´åˆã«ã€redirect_uri ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ OPTIONAL ã«ãªã‚‹ã“ã¨ãŒè¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚

>    "redirect_uri":  REQUIRED, if the redirect_uri parameter was included in the authorization request as described in Section 4.1.1, and in which case their values MUST be identical.  If no redirect_uri was included in the authorization request, this parameter is OPTIONAL.


### 4.3.  Refresh Token Grant

>   Refresh tokens MUST be kept confidential in transit and storage, and shared only among the authorization server and the client to whom the refresh tokens were issued.  The authorization server MUST maintain the binding between a refresh token and the client to whom it was issued.

### 5.2.  Bearer Tokens

>   To protect against access token disclosure, the communication interaction between the client and the resource server MUST utilize confidentiality and integrity protection as described in Section 1.5.

>    To mitigate the risk of access token capture and replay, the lifetime of the token MUST be limited.  One means of achieving this is by putting a validity time field inside the protected part of the token. Note that using short-lived tokens reduces the impact of them being leaked.

>    There is no requirement on the particular structure or format of a bearer token, as described in Section 5.  If a bearer token is a reference to authorization information, such references MUST be infeasible for an attacker to guess, such as using a sufficiently long cryptographically random string.  If a bearer token uses an encoding mechanism to contain the authorization information in the token itself, the access token MUST use integrity protection sufficient to prevent the token from being modified.  One example of an encoding and signing mechanism for access tokens is described in JSON Web Token Profile for Access Tokens [RFC9068].

### 7.15.  Other Recommendations

>   Authorization servers SHOULD NOT allow clients to influence their client_id or sub value or any other claim if that can cause confusion with a genuine resource owner (see (#client_impersonating)).

### 8.5. Security Considerations in Native Apps

ä»¥å‰ã¯ Security Considerations ã«ã¾ã¨ã‚ã‚‰ã‚Œã¦ã„ãŸ Native App ã® Security Consideration ãŒã€ãã‚Œã ã‘ã§æ–°è¦ã®ç« ã¨ã—ã¦è¿½è¨˜ã•ã‚Œã¾ã—ãŸã€‚
å†…å®¹ã¯ä»¥å‰ Security Considerations ã§è¨˜è¼‰ã•ã‚Œã¦ã„ãŸã‚‚ã®ã¨å¤§å·®ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

### 10.1.  Removal of the OAuth 2.0 Implicit grant

>   The OAuth 2.0 Implicit grant is omitted from OAuth 2.1 as it was deprecated in [I-D.ietf-oauth-security-topics].

>   The intent of removing the Implicit grant is to no longer issue access tokens in the authorization response, as such tokens are vulnerable to leakage and injection, and are unable to be sender-constrained to a client.  This behavior was indicated by clients using the response_type=token parameter.  This value for the response_type parameter is no longer defined in OAuth 2.1.

>   Removal of response_type=token does not have an effect on other extension response types returning other artifacts from the authorization endpoint, for example, response_type=id_token defined by [OpenID].

### çµ‚ã‚ã‚Š

ã§ã¯ã¾ãŸï¼